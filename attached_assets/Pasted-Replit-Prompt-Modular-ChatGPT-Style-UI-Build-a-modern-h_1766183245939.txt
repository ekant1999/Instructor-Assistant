Replit Prompt â€” Modular ChatGPT-Style UI

Build a modern, highly modular ChatGPT-style web UI for an â€œInstructor Assistantâ€ application.

The application must be chat-first, with the main chat experience as the front page, and all other pages implemented as independent, lazy-loaded modules that do not depend on each other.

1ï¸âƒ£ Tech Stack (required)

React + TypeScript

Vite

Tailwind CSS

Zustand for global state

React Router

No backend logic â€” use mocked API calls

2ï¸âƒ£ Global App Rules (important)

The App Shell (top bar + chat) is always mounted

Feature pages do not share state directly

Each page is:

Self-contained

Can be removed without breaking the app

Communicates only via typed interfaces

Chat is global and persistent across navigation

Dark mode supported via CSS variables

3ï¸âƒ£ App Layout (ChatGPT-like)
-------------------------------------------------
| Top Bar: Logo | Chat | Library | Notes | QSets |
-------------------------------------------------
|                                                 |
|   Main Content Area (varies by route)           |
|                                                 |
-------------------------------------------------
| Floating Chat Input (ChatGPT-style)             |
-------------------------------------------------

4ï¸âƒ£ FRONT PAGE â€” Chat (Primary Experience)

Route: /

This page should feel like ChatGPT.

UI Requirements

Full-height chat conversation

Message bubbles (user vs assistant)

Streaming response simulation

Tool usage indicators:

â€œReading PDFsâ€¦â€

â€œSearching Notesâ€¦â€

Message actions:

Save to Notes

Copy Markdown

Sticky input bar at bottom:

Multiline textarea

Enter = send, Shift+Enter = newline

Send button

Behavior

Chat can:

Answer questions

Suggest actions like:

â€œOpen Research Libraryâ€

â€œSave this as a noteâ€

â€œGenerate questionsâ€

Chat does not directly render other pages â€” it routes the user

This is the default landing page.

5ï¸âƒ£ Research Library Page

Route: /library

UI Layout

Left column: list of papers

Right panel: PDF preview area

Features

Upload paper by:

DOI

URL

Title (mocked)

Paper card:

Title

Source

Actions:

Preview

Summarize

Delete

â€œSummarizeâ€ sends content to Chat and allows saving to Notes

Independence Rule

Does not know about Notes internals

Emits events like:

onSummarize(paperId)

6ï¸âƒ£ Notes Workspace Page

Route: /notes

UI Layout

Left sidebar: searchable notes list

Main panel: note editor

Features

Markdown editor + preview

Word count

Inline text highlighting

Global search inside notes

Save / delete notes

Integration

Chat responses can be saved as notes

Notes page does not control chat

7ï¸âƒ£ Question Sets Page

Route: /questions

Two Tabs
A. Generate

Chat-like panel for generation

Stream questions one-by-one

Output Markdown preview

Buttons:

Regenerate question

Save set

B. Upload

Upload Markdown file

Edit existing sets

Delete sets

Question Model

Question

Options

Correct answer

Explanation

8ï¸âƒ£ RAG System Page

Route: /rag

UI Layout

Simple query input

Answer panel

Source citations list

Features

Simulated retrieval

Highlight cited chunks

â€œSend answer to Chatâ€ button

9ï¸âƒ£ Floating Agent (Global)

Component: QwenAgent

Behavior

Floating bubble bottom-right

Expand / minimize

Can:

Navigate pages

Trigger actions

Explain what tool itâ€™s using

Uses mock intent classification:

research

notes

questions

ğŸ”Ÿ Folder Structure (mandatory)
src/
  app/
    AppShell.tsx
    routes.tsx
  chat/
    ChatPage.tsx
    ChatInput.tsx
    ChatMessage.tsx
    store.ts
  library/
    LibraryPage.tsx
    PaperList.tsx
    PdfPreview.tsx
  notes/
    NotesPage.tsx
    NotesEditor.tsx
  questions/
    QuestionSetsPage.tsx
  rag/
    RagPage.tsx
  agent/
    QwenAgent.tsx
  shared/
    ui/
    hooks/
    types/

ğŸ¨ Design Goals

ChatGPT-like simplicity

No clutter

Modular, readable components

Easy to add/remove features

Feels fast and intentional

âœ… Output Expectations

Generate full React project

Include placeholder data

Focus on UI + architecture

Clean Tailwind styling

No backend required